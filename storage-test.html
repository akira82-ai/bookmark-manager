<!DOCTYPE html>
<html>
<head>
    <title>Chrome.Storageèƒ½åŠ›ä¼˜åŒ–ç³»ç»Ÿæµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .test-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #45a049;
        }
        .test-result {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .warning {
            color: #ffc107;
        }
        .info {
            color: #17a2b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chrome.Storageèƒ½åŠ›ä¼˜åŒ–ç³»ç»Ÿæµ‹è¯•</h1>

        <div class="test-section">
            <h2>1. å­˜å‚¨å¥åº·æ£€æµ‹</h2>
            <button class="test-button" onclick="testHealthCheck()">å¥åº·æ£€æŸ¥</button>
            <button class="test-button" onclick="toggleHealthMonitoring()">åˆ‡æ¢å¥åº·ç›‘æ§</button>
            <div id="health-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>2. åŸºç¡€å­˜å‚¨æ“ä½œ</h2>
            <button class="test-button" onclick="testStorageOperations()">æµ‹è¯•å­˜å‚¨æ“ä½œ</button>
            <button class="test-button" onclick="testRetryMechanism()">æµ‹è¯•é‡è¯•æœºåˆ¶</button>
            <div id="storage-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>3. æ¡£ä½é…ç½®æµ‹è¯•</h2>
            <button class="test-button" onclick="testLevelConfig()">æµ‹è¯•æ¡£ä½é…ç½®</button>
            <button class="test-button" onclick="simulateLevelChange()">æ¨¡æ‹Ÿæ¡£ä½åˆ‡æ¢</button>
            <div id="level-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>4. äº‹ä»¶ç³»ç»Ÿæµ‹è¯•</h2>
            <button class="test-button" onclick="testEventSystem()">æµ‹è¯•äº‹ä»¶ç³»ç»Ÿ</button>
            <button class="test-button" onclick="testCrossPageEvents()">æµ‹è¯•è·¨é¡µé¢äº‹ä»¶</button>
            <div id="event-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>5. æ€§èƒ½æµ‹è¯•</h2>
            <button class="test-button" onclick="testPerformance()">æ€§èƒ½æµ‹è¯•</button>
            <button class="test-button" onclick="testConcurrentAccess()">å¹¶å‘è®¿é—®æµ‹è¯•</button>
            <div id="performance-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>6. é”™è¯¯æ¢å¤æµ‹è¯•</h2>
            <button class="test-button" onclick="testErrorRecovery()">é”™è¯¯æ¢å¤æµ‹è¯•</button>
            <button class="test-button" onclick="testDataConsistency()">æ•°æ®ä¸€è‡´æ€§æµ‹è¯•</button>
            <div id="recovery-result" class="test-result"></div>
        </div>
    </div>

    <script>
        // å¤åˆ¶å­˜å‚¨ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½åˆ°æµ‹è¯•é¡µé¢
        // æ™ºèƒ½é‡è¯•æœºåˆ¶
        const StorageRetry = {
            maxAttempts: 3,
            retryDelay: 1000,
            exponentialBackoff: true,

            async retry(operation, attempt = 1) {
                try {
                    return await operation();
                } catch (error) {
                    if (attempt >= this.maxAttempts) throw error;

                    const delay = this.exponentialBackoff
                        ? this.retryDelay * Math.pow(2, attempt - 1)
                        : this.retryDelay;

                    await new Promise(resolve => setTimeout(resolve, delay));
                    return this.retry(operation, attempt + 1);
                }
            }
        };

        // åŒå†™åŒæ­¥ç­–ç•¥
        async function syncWrite(key, value) {
            const promises = [
                StorageRetry.retry(() => {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        return chrome.storage.local.set({[key]: value});
                    }
                    return Promise.resolve();
                }).catch(() => {
                    console.warn('Chrome.storageå†™å…¥å¤±è´¥ï¼Œå¿½ç•¥:', key);
                }),
                new Promise(resolve => {
                    try {
                        localStorage.setItem(key, JSON.stringify(value));
                        resolve();
                    } catch (error) {
                        console.warn('LocalStorageå†™å…¥å¤±è´¥:', error);
                        resolve();
                    }
                })
            ];

            await Promise.allSettled(promises);
        }

        // æ™ºèƒ½è¯»å–ç­–ç•¥
        async function smartRead(key, defaultValue) {
            // ä¼˜å…ˆçº§1: chrome.storage
            try {
                if (typeof chrome !== 'undefined' && chrome.storage) {
                    const result = await StorageRetry.retry(() =>
                        chrome.storage.local.get([key])
                    );
                    if (result[key] !== undefined) return result[key];
                }
            } catch (error) {
                console.warn('Chrome.storageè¯»å–å¤±è´¥ï¼Œå°è¯•fallback:', error);
            }

            // ä¼˜å…ˆçº§2: localStorage
            try {
                const localValue = localStorage.getItem(key);
                if (localValue !== null) {
                    return JSON.parse(localValue);
                }
            } catch (error) {
                console.warn('LocalStorageè¯»å–å¤±è´¥:', error);
            }

            // ä¼˜å…ˆçº§3: é»˜è®¤å€¼
            return defaultValue;
        }

        // å­˜å‚¨å¥åº·çŠ¶æ€ç›‘æ§
        const StorageHealth = {
            isHealthy: true,
            lastCheck: 0,
            checkInterval: 30000,

            async check() {
                try {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        const testKey = '_health_check';
                        await StorageRetry.retry(() =>
                            chrome.storage.local.set({[testKey]: Date.now()})
                        );
                        await StorageRetry.retry(() =>
                            chrome.storage.local.remove([testKey])
                        );
                        this.isHealthy = true;
                    }
                } catch (error) {
                    this.isHealthy = false;
                    console.warn('Chrome.storageå¥åº·æ£€æŸ¥å¤±è´¥:', error);
                }
                this.lastCheck = Date.now();
            },

            startMonitoring() {
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                }
                this.monitorInterval = setInterval(() => this.check(), this.checkInterval);
            },

            stopMonitoring() {
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                    this.monitorInterval = null;
                }
            }
        };

        // æ™ºèƒ½ç¼“å­˜ç®¡ç†
        class StorageCache {
            constructor(ttl = 60000) {
                this.cache = new Map();
                this.ttl = ttl;
            }

            get(key) {
                const item = this.cache.get(key);
                if (!item) return null;

                if (Date.now() - item.timestamp > this.ttl) {
                    this.cache.delete(key);
                    return null;
                }

                return item.value;
            }

            set(key, value) {
                this.cache.set(key, {
                    value,
                    timestamp: Date.now()
                });
            }

            invalidate(key) {
                this.cache.delete(key);
            }

            clear() {
                this.cache.clear();
            }
        }

        // å­˜å‚¨äº‹ä»¶ç³»ç»Ÿ
        class StorageEventSystem {
            constructor() {
                this.listeners = new Map();
                this.setupListeners();
            }

            setupListeners() {
                // Chromeå­˜å‚¨ç›‘å¬
                if (chrome.storage) {
                    chrome.storage.onChanged.addListener((changes, namespace) => {
                        this.emit('storage:changed', {changes, namespace});
                    });
                }

                // LocalStorageç›‘å¬
                window.addEventListener('storage', (event) => {
                    this.emit('localStorage:changed', event);
                });
            }

            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, new Set());
                }
                this.listeners.get(event).add(callback);
            }

            off(event, callback) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).delete(callback);
                }
            }

            emit(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('äº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥:', error);
                        }
                    });
                }
            }

            destroy() {
                this.listeners.clear();
            }
        }

        // ç»Ÿä¸€çš„å­˜å‚¨API
        class UnifiedStorage {
            constructor() {
                this.cache = new StorageCache();
                this.eventSystem = new StorageEventSystem();
                this.health = StorageHealth;
                this.initialize();
            }

            initialize() {
                // ç›‘å¬å­˜å‚¨å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°ç¼“å­˜
                this.eventSystem.on('storage:changed', ({changes}) => {
                    Object.keys(changes).forEach(key => {
                        const change = changes[key];
                        if (change.newValue !== undefined) {
                            this.cache.set(key, change.newValue);
                        } else {
                            this.cache.invalidate(key);
                        }
                    });
                });

                this.eventSystem.on('localStorage:changed', (event) => {
                    if (event.key && event.newValue !== null) {
                        try {
                            this.cache.set(event.key, JSON.parse(event.newValue));
                        } catch (error) {
                            console.warn('LocalStorageå€¼è§£æå¤±è´¥:', error);
                        }
                    }
                });
            }

            async get(key, defaultValue = null) {
                // å…ˆæ£€æŸ¥ç¼“å­˜
                const cached = this.cache.get(key);
                if (cached !== null) return cached;

                // æ™ºèƒ½è¯»å–
                const value = await smartRead(key, defaultValue);

                // æ›´æ–°ç¼“å­˜
                this.cache.set(key, value);

                return value;
            }

            async set(key, value) {
                // åŒå†™åŒæ­¥
                await syncWrite(key, value);

                // æ›´æ–°ç¼“å­˜
                this.cache.set(key, value);

                // è§¦å‘äº‹ä»¶
                this.eventSystem.emit('value:changed', {key, value});
            }

            async remove(key) {
                try {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        await StorageRetry.retry(() =>
                            chrome.storage.local.remove([key])
                        ).catch(() => {});
                    }

                    localStorage.removeItem(key);

                    this.cache.invalidate(key);

                    this.eventSystem.emit('value:removed', {key});
                } catch (error) {
                    console.warn('åˆ é™¤å­˜å‚¨é¡¹å¤±è´¥:', error);
                }
            }

            onValueChanged(callback) {
                this.eventSystem.on('value:changed', callback);
                this.eventSystem.on('value:removed', callback);
            }

            offValueChanged(callback) {
                this.eventSystem.off('value:changed', callback);
                this.eventSystem.off('value:removed', callback);
            }

            destroy() {
                this.eventSystem.destroy();
                this.cache.clear();
            }
        }

        // æµ‹è¯•ç”¨çš„å­˜å‚¨å®ä¾‹
        let testStorage = null;

        function getTestStorage() {
            if (!testStorage) {
                testStorage = new UnifiedStorage();
            }
            return testStorage;
        }

        // æµ‹è¯•å‡½æ•°
        async function testHealthCheck() {
            const resultDiv = document.getElementById('health-result');
            resultDiv.textContent = 'æ‰§è¡Œå¥åº·æ£€æŸ¥...\n';

            try {
                const health = StorageHealth;
                await health.check();

                resultDiv.textContent += `å¥åº·çŠ¶æ€: ${health.isHealthy ? 'âœ… å¥åº·' : 'âŒ ä¸å¥åº·'}\n`;
                resultDiv.textContent += `æœ€åæ£€æŸ¥æ—¶é—´: ${new Date(health.lastCheck).toLocaleTimeString()}\n`;
                resultDiv.textContent += `Chrome APIå¯ç”¨: ${typeof chrome !== 'undefined' && chrome.storage ? 'âœ…' : 'âŒ'}\n`;

                if (health.isHealthy) {
                    resultDiv.className = 'test-result success';
                } else {
                    resultDiv.className = 'test-result warning';
                }
            } catch (error) {
                resultDiv.textContent += `å¥åº·æ£€æŸ¥å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        let healthMonitoring = false;
        function toggleHealthMonitoring() {
            const resultDiv = document.getElementById('health-result');

            if (healthMonitoring) {
                StorageHealth.stopMonitoring();
                healthMonitoring = false;
                resultDiv.textContent = 'å¥åº·ç›‘æ§å·²åœæ­¢\n';
            } else {
                StorageHealth.startMonitoring();
                healthMonitoring = true;
                resultDiv.textContent = 'å¥åº·ç›‘æ§å·²å¯åŠ¨ (æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡)\n';
            }
            resultDiv.className = 'test-result info';
        }

        async function testStorageOperations() {
            const resultDiv = document.getElementById('storage-result');
            resultDiv.textContent = 'æµ‹è¯•åŸºç¡€å­˜å‚¨æ“ä½œ...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'test_operation_key';
                const testValue = {
                    timestamp: Date.now(),
                    random: Math.random(),
                    data: 'æµ‹è¯•æ•°æ®'
                };

                // æµ‹è¯•å†™å…¥
                await storage.set(testKey, testValue);
                resultDiv.textContent += 'âœ… å†™å…¥æ“ä½œæˆåŠŸ\n';

                // æµ‹è¯•è¯»å–
                const readValue = await storage.get(testKey);
                const isEqual = JSON.stringify(readValue) === JSON.stringify(testValue);
                resultDiv.textContent += `âœ… è¯»å–æ“ä½œæˆåŠŸï¼Œæ•°æ®ä¸€è‡´æ€§: ${isEqual ? 'âœ…' : 'âŒ'}\n`;

                // æµ‹è¯•ç¼“å­˜
                const cachedValue = storage.cache.get(testKey);
                const cacheConsistent = JSON.stringify(cachedValue) === JSON.stringify(testValue);
                resultDiv.textContent += `âœ… ç¼“å­˜ä¸€è‡´æ€§: ${cacheConsistent ? 'âœ…' : 'âŒ'}\n`;

                // æµ‹è¯•åˆ é™¤
                await storage.remove(testKey);
                const deletedValue = await storage.get(testKey, null);
                resultDiv.textContent += `âœ… åˆ é™¤æ“ä½œæˆåŠŸï¼Œæ•°æ®å·²æ¸…é™¤: ${deletedValue === null ? 'âœ…' : 'âŒ'}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ å­˜å‚¨æ“ä½œæµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testRetryMechanism() {
            const resultDiv = document.getElementById('storage-result');
            resultDiv.textContent = 'æµ‹è¯•é‡è¯•æœºåˆ¶...\n';

            try {
                let attemptCount = 0;
                const testKey = 'retry_test_key';

                // æ¨¡æ‹Ÿä¸€ä¸ªä¼šå¤±è´¥å‡ æ¬¡çš„æ“ä½œ
                const failingOperation = async () => {
                    attemptCount++;
                    if (attemptCount < 3) {
                        throw new Error(`æ¨¡æ‹Ÿå¤±è´¥ (å°è¯• ${attemptCount})`);
                    }
                    return 'æˆåŠŸ';
                };

                const result = await StorageRetry.retry(failingOperation);
                resultDiv.textContent += `âœ… é‡è¯•æœºåˆ¶å·¥ä½œæ­£å¸¸ï¼Œæœ€ç»ˆç»“æœ: ${result}\n`;
                resultDiv.textContent += `æ€»å…±å°è¯•æ¬¡æ•°: ${attemptCount}\n`;
                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ é‡è¯•æœºåˆ¶æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testLevelConfig() {
            const resultDiv = document.getElementById('level-result');
            resultDiv.textContent = 'æµ‹è¯•æ¡£ä½é…ç½®...\n';

            try {
                const storage = getTestStorage();
                const testLevels = [0, 1, 2, 3, 4];
                const levelNames = ['å¾ˆå°‘æé†’', 'å¶å°”æé†’', 'é€‚ä¸­æé†’', 'å¸¸å¸¸æé†’', 'é¢‘ç¹æé†’'];

                for (let level of testLevels) {
                    await storage.set('reminder-sensitivity-level', level);
                    const readLevel = await storage.get('reminder-sensitivity-level', -1);
                    const success = readLevel === level;

                    resultDiv.textContent += `${success ? 'âœ…' : 'âŒ'} æ¡£ä½ ${level} (${levelNames[level]}): ${success ? 'æˆåŠŸ' : 'å¤±è´¥'}\n`;
                }

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ æ¡£ä½é…ç½®æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function simulateLevelChange() {
            const resultDiv = document.getElementById('level-result');
            resultDiv.textContent = 'æ¨¡æ‹Ÿæ¡£ä½åˆ‡æ¢...\n';

            try {
                const storage = getTestStorage();

                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                let eventReceived = false;
                const eventHandler = ({key, value}) => {
                    if (key === 'reminder-sensitivity-level') {
                        eventReceived = true;
                        resultDiv.textContent += `ğŸ“¡ æ”¶åˆ°æ¡£ä½å˜åŒ–äº‹ä»¶: æ¡£ä½ ${value}\n`;
                    }
                };

                storage.onValueChanged(eventHandler);

                // æ¨¡æ‹Ÿå¤šä¸ªæ¡£ä½åˆ‡æ¢
                const testSequence = [2, 0, 4, 1, 3, 2];
                for (let level of testSequence) {
                    await storage.set('reminder-sensitivity-level', level);
                    resultDiv.textContent += `ğŸ”„ åˆ‡æ¢åˆ°æ¡£ä½: ${level}\n`;
                    await new Promise(resolve => setTimeout(resolve, 100)); // çŸ­æš‚å»¶è¿Ÿ
                }

                // ç­‰å¾…äº‹ä»¶å¤„ç†
                await new Promise(resolve => setTimeout(resolve, 500));

                storage.offValueChanged(eventHandler);

                resultDiv.textContent += `âœ… æ¡£ä½åˆ‡æ¢æ¨¡æ‹Ÿå®Œæˆï¼Œäº‹ä»¶æ¥æ”¶: ${eventReceived ? 'âœ…' : 'âŒ'}\n`;
                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ æ¡£ä½åˆ‡æ¢æ¨¡æ‹Ÿå¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testEventSystem() {
            const resultDiv = document.getElementById('event-result');
            resultDiv.textContent = 'æµ‹è¯•äº‹ä»¶ç³»ç»Ÿ...\n';

            try {
                const storage = getTestStorage();
                const events = [];

                // ç›‘å¬æ‰€æœ‰äº‹ä»¶
                const eventHandler = (data) => {
                    events.push({
                        type: data.type || 'unknown',
                        timestamp: Date.now(),
                        data: data
                    });
                };

                storage.onValueChanged(eventHandler);

                // è§¦å‘å¤šä¸ªå­˜å‚¨æ“ä½œ
                await storage.set('test_event_1', 'value1');
                await storage.set('test_event_2', {data: 'value2'});
                await storage.remove('test_event_1');

                // ç­‰å¾…äº‹ä»¶å¤„ç†
                await new Promise(resolve => setTimeout(resolve, 200));

                storage.offValueChanged(eventHandler);

                resultDiv.textContent += `âœ… äº‹ä»¶ç³»ç»Ÿæµ‹è¯•å®Œæˆ\n`;
                resultDiv.textContent += `æ¥æ”¶åˆ°äº‹ä»¶æ•°é‡: ${events.length}\n`;

                events.forEach((event, index) => {
                    resultDiv.textContent += `äº‹ä»¶ ${index + 1}: ${JSON.stringify(event.data)}\n`;
                });

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ äº‹ä»¶ç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testCrossPageEvents() {
            const resultDiv = document.getElementById('event-result');
            resultDiv.textContent = 'æµ‹è¯•è·¨é¡µé¢äº‹ä»¶...\n';

            try {
                // åœ¨localStorageä¸­è®¾ç½®ä¸€ä¸ªæµ‹è¯•å€¼
                const testKey = 'cross_page_test';
                const testValue = {
                    timestamp: Date.now(),
                    source: 'test_page'
                };

                localStorage.setItem(testKey, JSON.stringify(testValue));

                // è§¦å‘storageäº‹ä»¶ï¼ˆåœ¨å…¶ä»–é¡µé¢ä¸­ï¼‰
                window.dispatchEvent(new StorageEvent('storage', {
                    key: testKey,
                    newValue: JSON.stringify(testValue),
                    url: window.location.href
                }));

                resultDiv.textContent += `âœ… è·¨é¡µé¢äº‹ä»¶æµ‹è¯•å®Œæˆ\n`;
                resultDiv.textContent += `æµ‹è¯•å€¼å·²å†™å…¥localStorage\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ è·¨é¡µé¢äº‹ä»¶æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testPerformance() {
            const resultDiv = document.getElementById('performance-result');
            resultDiv.textContent = 'æµ‹è¯•æ€§èƒ½...\n';

            try {
                const storage = getTestStorage();
                const iterations = 100;
                const testKey = 'performance_test';

                // æµ‹è¯•å†™å…¥æ€§èƒ½
                const writeStart = Date.now();
                for (let i = 0; i < iterations; i++) {
                    await storage.set(`${testKey}_${i}`, {index: i, data: 'test'.repeat(100)});
                }
                const writeTime = Date.now() - writeStart;

                // æµ‹è¯•è¯»å–æ€§èƒ½
                const readStart = Date.now();
                for (let i = 0; i < iterations; i++) {
                    await storage.get(`${testKey}_${i}`);
                }
                const readTime = Date.now() - readStart;

                // æ¸…ç†æµ‹è¯•æ•°æ®
                for (let i = 0; i < iterations; i++) {
                    await storage.remove(`${testKey}_${i}`);
                }

                resultDiv.textContent += `âœ… æ€§èƒ½æµ‹è¯•å®Œæˆ (${iterations} æ¬¡æ“ä½œ)\n`;
                resultDiv.textContent += `å†™å…¥æ€§èƒ½: ${writeTime}ms (å¹³å‡ ${(writeTime/iterations).toFixed(2)}ms/æ“ä½œ)\n`;
                resultDiv.textContent += `è¯»å–æ€§èƒ½: ${readTime}ms (å¹³å‡ ${(readTime/iterations).toFixed(2)}ms/æ“ä½œ)\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testConcurrentAccess() {
            const resultDiv = document.getElementById('performance-result');
            resultDiv.textContent = 'æµ‹è¯•å¹¶å‘è®¿é—®...\n';

            try {
                const storage = getTestStorage();
                const concurrentOperations = 10;
                const testKey = 'concurrent_test';

                // åˆ›å»ºå¹¶å‘æ“ä½œ
                const promises = [];
                for (let i = 0; i < concurrentOperations; i++) {
                    promises.push((async () => {
                        const value = {worker: i, timestamp: Date.now()};
                        await storage.set(`${testKey}_${i}`, value);
                        const readValue = await storage.get(`${testKey}_${i}`);
                        return readValue;
                    })());
                }

                const results = await Promise.allSettled(promises);

                // æ£€æŸ¥ç»“æœ
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;

                // æ¸…ç†
                for (let i = 0; i < concurrentOperations; i++) {
                    await storage.remove(`${testKey}_${i}`);
                }

                resultDiv.textContent += `âœ… å¹¶å‘è®¿é—®æµ‹è¯•å®Œæˆ\n`;
                resultDiv.textContent += `å¹¶å‘æ“ä½œæ•°: ${concurrentOperations}\n`;
                resultDiv.textContent += `æˆåŠŸæ“ä½œ: ${successful}\n`;
                resultDiv.textContent += `å¤±è´¥æ“ä½œ: ${failed}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ å¹¶å‘è®¿é—®æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testErrorRecovery() {
            const resultDiv = document.getElementById('recovery-result');
            resultDiv.textContent = 'æµ‹è¯•é”™è¯¯æ¢å¤...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'error_recovery_test';

                // æµ‹è¯•ä»Chrome.storageå¤±è´¥ä¸­æ¢å¤
                let chromeStorageFailed = false;
                const originalChromeStorage = chrome.storage;

                // æ¨¡æ‹ŸChrome.storageå¤±æ•ˆ
                if (typeof chrome !== 'undefined') {
                    chrome.storage = null;
                }

                try {
                    await storage.set(testKey, 'test_value');
                    // å¦‚æœåˆ°è¿™é‡Œè¯´æ˜é™çº§æˆåŠŸ
                    chromeStorageFailed = true;
                } catch (error) {
                    console.warn('é™çº§å­˜å‚¨å¤±è´¥:', error);
                }

                // æ¢å¤Chrome.storage
                if (originalChromeStorage) {
                    chrome.storage = originalChromeStorage;
                }

                // éªŒè¯æ•°æ®æ˜¯å¦æ­£ç¡®ä¿å­˜åˆ°localStorage
                const localValue = localStorage.getItem(testKey);
                const recoverySuccess = localValue === JSON.stringify('test_value');

                // æ¸…ç†
                localStorage.removeItem(testKey);

                resultDiv.textContent += `âœ… é”™è¯¯æ¢å¤æµ‹è¯•å®Œæˆ\n`;
                resultDiv.textContent += `Chrome.storageå¤±æ•ˆæ£€æµ‹: ${chromeStorageFailed ? 'âœ…' : 'âŒ'}\n`;
                resultDiv.textContent += `LocalStorageé™çº§æˆåŠŸ: ${recoverySuccess ? 'âœ…' : 'âŒ'}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `âŒ é”™è¯¯æ¢å¤æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testDataConsistency() {
            const resultDiv = document.getElementById('recovery-result');
            resultDiv.textContent = 'æµ‹è¯•æ•°æ®ä¸€è‡´æ€§...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'consistency_test';
                const testValue = {
                    id: Date.now(),
                    data: 'consistency_test_data',
                    nested: {
                        value: 42,
                        array: [1, 2, 3]
                    }
                };

                // å¤šæ¬¡å†™å…¥å’Œè¯»å–éªŒè¯ä¸€è‡´æ€§
                const consistencyChecks = 5;
                let allConsistent = true;

                for (let i = 0; i < consistencyChecks; i++) {
                    await storage.set(testKey, testValue);
                    const readValue = await storage.get(testKey);

                    const isConsistent = JSON.stringify(readValue) === JSON.stringify(testValue);
                    if (!isConsistent) {
                        allConsistent = false;
                        resultDiv.textContent += `âŒ ç¬¬${i + 1}æ¬¡æ£€æŸ¥ä¸ä¸€è‡´\n`;
                    }

                    // çŸ­æš‚å»¶è¿Ÿ
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // æ¸…ç†
                await storage.remove(testKey);

                resultDiv.textContent += `âœ… æ•°æ®ä¸€è‡´æ€§æµ‹è¯•å®Œæˆ\n`;
                resultDiv.textContent += `ä¸€è‡´æ€§æ£€æŸ¥æ¬¡æ•°: ${consistencyChecks}\n`;
                resultDiv.textContent += `æ‰€æœ‰æ£€æŸ¥é€šè¿‡: ${allConsistent ? 'âœ…' : 'âŒ'}\n`;

                resultDiv.className = allConsistent ? 'test-result success' : 'test-result error';
            } catch (error) {
                resultDiv.textContent += `âŒ æ•°æ®ä¸€è‡´æ€§æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡ŒåŸºç¡€æµ‹è¯•
        window.addEventListener('load', async () => {
            console.log('Chrome.Storageèƒ½åŠ›ä¼˜åŒ–ç³»ç»Ÿæµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ');

            // è‡ªåŠ¨è¿è¡Œå¥åº·æ£€æŸ¥
            await testHealthCheck();

            // å¯åŠ¨å¥åº·ç›‘æ§
            StorageHealth.startMonitoring();
            healthMonitoring = true;
        });
    </script>
</body>
</html>