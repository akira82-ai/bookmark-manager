<!DOCTYPE html>
<html>
<head>
    <title>Chrome.Storage能力优化系统测试</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .test-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #45a049;
        }
        .test-result {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .warning {
            color: #ffc107;
        }
        .info {
            color: #17a2b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chrome.Storage能力优化系统测试</h1>

        <div class="test-section">
            <h2>1. 存储健康检测</h2>
            <button class="test-button" onclick="testHealthCheck()">健康检查</button>
            <button class="test-button" onclick="toggleHealthMonitoring()">切换健康监控</button>
            <div id="health-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>2. 基础存储操作</h2>
            <button class="test-button" onclick="testStorageOperations()">测试存储操作</button>
            <button class="test-button" onclick="testRetryMechanism()">测试重试机制</button>
            <div id="storage-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>3. 档位配置测试</h2>
            <button class="test-button" onclick="testLevelConfig()">测试档位配置</button>
            <button class="test-button" onclick="simulateLevelChange()">模拟档位切换</button>
            <div id="level-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>4. 事件系统测试</h2>
            <button class="test-button" onclick="testEventSystem()">测试事件系统</button>
            <button class="test-button" onclick="testCrossPageEvents()">测试跨页面事件</button>
            <div id="event-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>5. 性能测试</h2>
            <button class="test-button" onclick="testPerformance()">性能测试</button>
            <button class="test-button" onclick="testConcurrentAccess()">并发访问测试</button>
            <div id="performance-result" class="test-result"></div>
        </div>

        <div class="test-section">
            <h2>6. 错误恢复测试</h2>
            <button class="test-button" onclick="testErrorRecovery()">错误恢复测试</button>
            <button class="test-button" onclick="testDataConsistency()">数据一致性测试</button>
            <div id="recovery-result" class="test-result"></div>
        </div>
    </div>

    <script>
        // 复制存储系统的核心功能到测试页面
        // 智能重试机制
        const StorageRetry = {
            maxAttempts: 3,
            retryDelay: 1000,
            exponentialBackoff: true,

            async retry(operation, attempt = 1) {
                try {
                    return await operation();
                } catch (error) {
                    if (attempt >= this.maxAttempts) throw error;

                    const delay = this.exponentialBackoff
                        ? this.retryDelay * Math.pow(2, attempt - 1)
                        : this.retryDelay;

                    await new Promise(resolve => setTimeout(resolve, delay));
                    return this.retry(operation, attempt + 1);
                }
            }
        };

        // 双写同步策略
        async function syncWrite(key, value) {
            const promises = [
                StorageRetry.retry(() => {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        return chrome.storage.local.set({[key]: value});
                    }
                    return Promise.resolve();
                }).catch(() => {
                    console.warn('Chrome.storage写入失败，忽略:', key);
                }),
                new Promise(resolve => {
                    try {
                        localStorage.setItem(key, JSON.stringify(value));
                        resolve();
                    } catch (error) {
                        console.warn('LocalStorage写入失败:', error);
                        resolve();
                    }
                })
            ];

            await Promise.allSettled(promises);
        }

        // 智能读取策略
        async function smartRead(key, defaultValue) {
            // 优先级1: chrome.storage
            try {
                if (typeof chrome !== 'undefined' && chrome.storage) {
                    const result = await StorageRetry.retry(() =>
                        chrome.storage.local.get([key])
                    );
                    if (result[key] !== undefined) return result[key];
                }
            } catch (error) {
                console.warn('Chrome.storage读取失败，尝试fallback:', error);
            }

            // 优先级2: localStorage
            try {
                const localValue = localStorage.getItem(key);
                if (localValue !== null) {
                    return JSON.parse(localValue);
                }
            } catch (error) {
                console.warn('LocalStorage读取失败:', error);
            }

            // 优先级3: 默认值
            return defaultValue;
        }

        // 存储健康状态监控
        const StorageHealth = {
            isHealthy: true,
            lastCheck: 0,
            checkInterval: 30000,

            async check() {
                try {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        const testKey = '_health_check';
                        await StorageRetry.retry(() =>
                            chrome.storage.local.set({[testKey]: Date.now()})
                        );
                        await StorageRetry.retry(() =>
                            chrome.storage.local.remove([testKey])
                        );
                        this.isHealthy = true;
                    }
                } catch (error) {
                    this.isHealthy = false;
                    console.warn('Chrome.storage健康检查失败:', error);
                }
                this.lastCheck = Date.now();
            },

            startMonitoring() {
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                }
                this.monitorInterval = setInterval(() => this.check(), this.checkInterval);
            },

            stopMonitoring() {
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                    this.monitorInterval = null;
                }
            }
        };

        // 智能缓存管理
        class StorageCache {
            constructor(ttl = 60000) {
                this.cache = new Map();
                this.ttl = ttl;
            }

            get(key) {
                const item = this.cache.get(key);
                if (!item) return null;

                if (Date.now() - item.timestamp > this.ttl) {
                    this.cache.delete(key);
                    return null;
                }

                return item.value;
            }

            set(key, value) {
                this.cache.set(key, {
                    value,
                    timestamp: Date.now()
                });
            }

            invalidate(key) {
                this.cache.delete(key);
            }

            clear() {
                this.cache.clear();
            }
        }

        // 存储事件系统
        class StorageEventSystem {
            constructor() {
                this.listeners = new Map();
                this.setupListeners();
            }

            setupListeners() {
                // Chrome存储监听
                if (chrome.storage) {
                    chrome.storage.onChanged.addListener((changes, namespace) => {
                        this.emit('storage:changed', {changes, namespace});
                    });
                }

                // LocalStorage监听
                window.addEventListener('storage', (event) => {
                    this.emit('localStorage:changed', event);
                });
            }

            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, new Set());
                }
                this.listeners.get(event).add(callback);
            }

            off(event, callback) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).delete(callback);
                }
            }

            emit(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('事件监听器执行失败:', error);
                        }
                    });
                }
            }

            destroy() {
                this.listeners.clear();
            }
        }

        // 统一的存储API
        class UnifiedStorage {
            constructor() {
                this.cache = new StorageCache();
                this.eventSystem = new StorageEventSystem();
                this.health = StorageHealth;
                this.initialize();
            }

            initialize() {
                // 监听存储变化，自动更新缓存
                this.eventSystem.on('storage:changed', ({changes}) => {
                    Object.keys(changes).forEach(key => {
                        const change = changes[key];
                        if (change.newValue !== undefined) {
                            this.cache.set(key, change.newValue);
                        } else {
                            this.cache.invalidate(key);
                        }
                    });
                });

                this.eventSystem.on('localStorage:changed', (event) => {
                    if (event.key && event.newValue !== null) {
                        try {
                            this.cache.set(event.key, JSON.parse(event.newValue));
                        } catch (error) {
                            console.warn('LocalStorage值解析失败:', error);
                        }
                    }
                });
            }

            async get(key, defaultValue = null) {
                // 先检查缓存
                const cached = this.cache.get(key);
                if (cached !== null) return cached;

                // 智能读取
                const value = await smartRead(key, defaultValue);

                // 更新缓存
                this.cache.set(key, value);

                return value;
            }

            async set(key, value) {
                // 双写同步
                await syncWrite(key, value);

                // 更新缓存
                this.cache.set(key, value);

                // 触发事件
                this.eventSystem.emit('value:changed', {key, value});
            }

            async remove(key) {
                try {
                    if (typeof chrome !== 'undefined' && chrome.storage) {
                        await StorageRetry.retry(() =>
                            chrome.storage.local.remove([key])
                        ).catch(() => {});
                    }

                    localStorage.removeItem(key);

                    this.cache.invalidate(key);

                    this.eventSystem.emit('value:removed', {key});
                } catch (error) {
                    console.warn('删除存储项失败:', error);
                }
            }

            onValueChanged(callback) {
                this.eventSystem.on('value:changed', callback);
                this.eventSystem.on('value:removed', callback);
            }

            offValueChanged(callback) {
                this.eventSystem.off('value:changed', callback);
                this.eventSystem.off('value:removed', callback);
            }

            destroy() {
                this.eventSystem.destroy();
                this.cache.clear();
            }
        }

        // 测试用的存储实例
        let testStorage = null;

        function getTestStorage() {
            if (!testStorage) {
                testStorage = new UnifiedStorage();
            }
            return testStorage;
        }

        // 测试函数
        async function testHealthCheck() {
            const resultDiv = document.getElementById('health-result');
            resultDiv.textContent = '执行健康检查...\n';

            try {
                const health = StorageHealth;
                await health.check();

                resultDiv.textContent += `健康状态: ${health.isHealthy ? '✅ 健康' : '❌ 不健康'}\n`;
                resultDiv.textContent += `最后检查时间: ${new Date(health.lastCheck).toLocaleTimeString()}\n`;
                resultDiv.textContent += `Chrome API可用: ${typeof chrome !== 'undefined' && chrome.storage ? '✅' : '❌'}\n`;

                if (health.isHealthy) {
                    resultDiv.className = 'test-result success';
                } else {
                    resultDiv.className = 'test-result warning';
                }
            } catch (error) {
                resultDiv.textContent += `健康检查失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        let healthMonitoring = false;
        function toggleHealthMonitoring() {
            const resultDiv = document.getElementById('health-result');

            if (healthMonitoring) {
                StorageHealth.stopMonitoring();
                healthMonitoring = false;
                resultDiv.textContent = '健康监控已停止\n';
            } else {
                StorageHealth.startMonitoring();
                healthMonitoring = true;
                resultDiv.textContent = '健康监控已启动 (每30秒检查一次)\n';
            }
            resultDiv.className = 'test-result info';
        }

        async function testStorageOperations() {
            const resultDiv = document.getElementById('storage-result');
            resultDiv.textContent = '测试基础存储操作...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'test_operation_key';
                const testValue = {
                    timestamp: Date.now(),
                    random: Math.random(),
                    data: '测试数据'
                };

                // 测试写入
                await storage.set(testKey, testValue);
                resultDiv.textContent += '✅ 写入操作成功\n';

                // 测试读取
                const readValue = await storage.get(testKey);
                const isEqual = JSON.stringify(readValue) === JSON.stringify(testValue);
                resultDiv.textContent += `✅ 读取操作成功，数据一致性: ${isEqual ? '✅' : '❌'}\n`;

                // 测试缓存
                const cachedValue = storage.cache.get(testKey);
                const cacheConsistent = JSON.stringify(cachedValue) === JSON.stringify(testValue);
                resultDiv.textContent += `✅ 缓存一致性: ${cacheConsistent ? '✅' : '❌'}\n`;

                // 测试删除
                await storage.remove(testKey);
                const deletedValue = await storage.get(testKey, null);
                resultDiv.textContent += `✅ 删除操作成功，数据已清除: ${deletedValue === null ? '✅' : '❌'}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 存储操作测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testRetryMechanism() {
            const resultDiv = document.getElementById('storage-result');
            resultDiv.textContent = '测试重试机制...\n';

            try {
                let attemptCount = 0;
                const testKey = 'retry_test_key';

                // 模拟一个会失败几次的操作
                const failingOperation = async () => {
                    attemptCount++;
                    if (attemptCount < 3) {
                        throw new Error(`模拟失败 (尝试 ${attemptCount})`);
                    }
                    return '成功';
                };

                const result = await StorageRetry.retry(failingOperation);
                resultDiv.textContent += `✅ 重试机制工作正常，最终结果: ${result}\n`;
                resultDiv.textContent += `总共尝试次数: ${attemptCount}\n`;
                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 重试机制测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testLevelConfig() {
            const resultDiv = document.getElementById('level-result');
            resultDiv.textContent = '测试档位配置...\n';

            try {
                const storage = getTestStorage();
                const testLevels = [0, 1, 2, 3, 4];
                const levelNames = ['很少提醒', '偶尔提醒', '适中提醒', '常常提醒', '频繁提醒'];

                for (let level of testLevels) {
                    await storage.set('reminder-sensitivity-level', level);
                    const readLevel = await storage.get('reminder-sensitivity-level', -1);
                    const success = readLevel === level;

                    resultDiv.textContent += `${success ? '✅' : '❌'} 档位 ${level} (${levelNames[level]}): ${success ? '成功' : '失败'}\n`;
                }

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 档位配置测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function simulateLevelChange() {
            const resultDiv = document.getElementById('level-result');
            resultDiv.textContent = '模拟档位切换...\n';

            try {
                const storage = getTestStorage();

                // 设置事件监听器
                let eventReceived = false;
                const eventHandler = ({key, value}) => {
                    if (key === 'reminder-sensitivity-level') {
                        eventReceived = true;
                        resultDiv.textContent += `📡 收到档位变化事件: 档位 ${value}\n`;
                    }
                };

                storage.onValueChanged(eventHandler);

                // 模拟多个档位切换
                const testSequence = [2, 0, 4, 1, 3, 2];
                for (let level of testSequence) {
                    await storage.set('reminder-sensitivity-level', level);
                    resultDiv.textContent += `🔄 切换到档位: ${level}\n`;
                    await new Promise(resolve => setTimeout(resolve, 100)); // 短暂延迟
                }

                // 等待事件处理
                await new Promise(resolve => setTimeout(resolve, 500));

                storage.offValueChanged(eventHandler);

                resultDiv.textContent += `✅ 档位切换模拟完成，事件接收: ${eventReceived ? '✅' : '❌'}\n`;
                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 档位切换模拟失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testEventSystem() {
            const resultDiv = document.getElementById('event-result');
            resultDiv.textContent = '测试事件系统...\n';

            try {
                const storage = getTestStorage();
                const events = [];

                // 监听所有事件
                const eventHandler = (data) => {
                    events.push({
                        type: data.type || 'unknown',
                        timestamp: Date.now(),
                        data: data
                    });
                };

                storage.onValueChanged(eventHandler);

                // 触发多个存储操作
                await storage.set('test_event_1', 'value1');
                await storage.set('test_event_2', {data: 'value2'});
                await storage.remove('test_event_1');

                // 等待事件处理
                await new Promise(resolve => setTimeout(resolve, 200));

                storage.offValueChanged(eventHandler);

                resultDiv.textContent += `✅ 事件系统测试完成\n`;
                resultDiv.textContent += `接收到事件数量: ${events.length}\n`;

                events.forEach((event, index) => {
                    resultDiv.textContent += `事件 ${index + 1}: ${JSON.stringify(event.data)}\n`;
                });

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 事件系统测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testCrossPageEvents() {
            const resultDiv = document.getElementById('event-result');
            resultDiv.textContent = '测试跨页面事件...\n';

            try {
                // 在localStorage中设置一个测试值
                const testKey = 'cross_page_test';
                const testValue = {
                    timestamp: Date.now(),
                    source: 'test_page'
                };

                localStorage.setItem(testKey, JSON.stringify(testValue));

                // 触发storage事件（在其他页面中）
                window.dispatchEvent(new StorageEvent('storage', {
                    key: testKey,
                    newValue: JSON.stringify(testValue),
                    url: window.location.href
                }));

                resultDiv.textContent += `✅ 跨页面事件测试完成\n`;
                resultDiv.textContent += `测试值已写入localStorage\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 跨页面事件测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testPerformance() {
            const resultDiv = document.getElementById('performance-result');
            resultDiv.textContent = '测试性能...\n';

            try {
                const storage = getTestStorage();
                const iterations = 100;
                const testKey = 'performance_test';

                // 测试写入性能
                const writeStart = Date.now();
                for (let i = 0; i < iterations; i++) {
                    await storage.set(`${testKey}_${i}`, {index: i, data: 'test'.repeat(100)});
                }
                const writeTime = Date.now() - writeStart;

                // 测试读取性能
                const readStart = Date.now();
                for (let i = 0; i < iterations; i++) {
                    await storage.get(`${testKey}_${i}`);
                }
                const readTime = Date.now() - readStart;

                // 清理测试数据
                for (let i = 0; i < iterations; i++) {
                    await storage.remove(`${testKey}_${i}`);
                }

                resultDiv.textContent += `✅ 性能测试完成 (${iterations} 次操作)\n`;
                resultDiv.textContent += `写入性能: ${writeTime}ms (平均 ${(writeTime/iterations).toFixed(2)}ms/操作)\n`;
                resultDiv.textContent += `读取性能: ${readTime}ms (平均 ${(readTime/iterations).toFixed(2)}ms/操作)\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 性能测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testConcurrentAccess() {
            const resultDiv = document.getElementById('performance-result');
            resultDiv.textContent = '测试并发访问...\n';

            try {
                const storage = getTestStorage();
                const concurrentOperations = 10;
                const testKey = 'concurrent_test';

                // 创建并发操作
                const promises = [];
                for (let i = 0; i < concurrentOperations; i++) {
                    promises.push((async () => {
                        const value = {worker: i, timestamp: Date.now()};
                        await storage.set(`${testKey}_${i}`, value);
                        const readValue = await storage.get(`${testKey}_${i}`);
                        return readValue;
                    })());
                }

                const results = await Promise.allSettled(promises);

                // 检查结果
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;

                // 清理
                for (let i = 0; i < concurrentOperations; i++) {
                    await storage.remove(`${testKey}_${i}`);
                }

                resultDiv.textContent += `✅ 并发访问测试完成\n`;
                resultDiv.textContent += `并发操作数: ${concurrentOperations}\n`;
                resultDiv.textContent += `成功操作: ${successful}\n`;
                resultDiv.textContent += `失败操作: ${failed}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 并发访问测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testErrorRecovery() {
            const resultDiv = document.getElementById('recovery-result');
            resultDiv.textContent = '测试错误恢复...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'error_recovery_test';

                // 测试从Chrome.storage失败中恢复
                let chromeStorageFailed = false;
                const originalChromeStorage = chrome.storage;

                // 模拟Chrome.storage失效
                if (typeof chrome !== 'undefined') {
                    chrome.storage = null;
                }

                try {
                    await storage.set(testKey, 'test_value');
                    // 如果到这里说明降级成功
                    chromeStorageFailed = true;
                } catch (error) {
                    console.warn('降级存储失败:', error);
                }

                // 恢复Chrome.storage
                if (originalChromeStorage) {
                    chrome.storage = originalChromeStorage;
                }

                // 验证数据是否正确保存到localStorage
                const localValue = localStorage.getItem(testKey);
                const recoverySuccess = localValue === JSON.stringify('test_value');

                // 清理
                localStorage.removeItem(testKey);

                resultDiv.textContent += `✅ 错误恢复测试完成\n`;
                resultDiv.textContent += `Chrome.storage失效检测: ${chromeStorageFailed ? '✅' : '❌'}\n`;
                resultDiv.textContent += `LocalStorage降级成功: ${recoverySuccess ? '✅' : '❌'}\n`;

                resultDiv.className = 'test-result success';
            } catch (error) {
                resultDiv.textContent += `❌ 错误恢复测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        async function testDataConsistency() {
            const resultDiv = document.getElementById('recovery-result');
            resultDiv.textContent = '测试数据一致性...\n';

            try {
                const storage = getTestStorage();
                const testKey = 'consistency_test';
                const testValue = {
                    id: Date.now(),
                    data: 'consistency_test_data',
                    nested: {
                        value: 42,
                        array: [1, 2, 3]
                    }
                };

                // 多次写入和读取验证一致性
                const consistencyChecks = 5;
                let allConsistent = true;

                for (let i = 0; i < consistencyChecks; i++) {
                    await storage.set(testKey, testValue);
                    const readValue = await storage.get(testKey);

                    const isConsistent = JSON.stringify(readValue) === JSON.stringify(testValue);
                    if (!isConsistent) {
                        allConsistent = false;
                        resultDiv.textContent += `❌ 第${i + 1}次检查不一致\n`;
                    }

                    // 短暂延迟
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // 清理
                await storage.remove(testKey);

                resultDiv.textContent += `✅ 数据一致性测试完成\n`;
                resultDiv.textContent += `一致性检查次数: ${consistencyChecks}\n`;
                resultDiv.textContent += `所有检查通过: ${allConsistent ? '✅' : '❌'}\n`;

                resultDiv.className = allConsistent ? 'test-result success' : 'test-result error';
            } catch (error) {
                resultDiv.textContent += `❌ 数据一致性测试失败: ${error.message}\n`;
                resultDiv.className = 'test-result error';
            }
        }

        // 页面加载时自动运行基础测试
        window.addEventListener('load', async () => {
            console.log('Chrome.Storage能力优化系统测试页面加载完成');

            // 自动运行健康检查
            await testHealthCheck();

            // 启动健康监控
            StorageHealth.startMonitoring();
            healthMonitoring = true;
        });
    </script>
</body>
</html>